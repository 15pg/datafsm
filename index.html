<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
  <link rel="stylesheet" href="stylesheets/github-dark.css">
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script type="text/javascript" src="javascripts/script.js"></script>

  <title>datafsm</title>
  <meta name="description" content="Estimating Finite State Machine Models from Data">

  <meta name="viewport" content="width=device-width,initial-scale=1">

</head>

<body>

  <div class="wrapper">
    <header>
      <h1 class="title">datafsm</h1>
    </header>
    <div id="container">
      <p class="tagline">Estimating Finite State Machine Models from Data</p>
      <div id="main" role="main">
        <div class="download-bar">
        <div class="inner">
          <a href="https://github.com/JohnNay/datafsm/tarball/master" class="download-button tar"><span>Download</span></a>
          <a href="https://github.com/JohnNay/datafsm/zipball/master" class="download-button zip"><span>Download</span></a>
          <a href="https://github.com/JohnNay/datafsm" class="code">View datafsm on GitHub</a>
        </div>
        <span class="blc"></span><span class="trc"></span>
        </div>
        <article class="markdown-body">
          

<p><a href="https://travis-ci.org/JohnNay/datafsm"><img src="https://travis-ci.org/JohnNay/datafsm.png?branch=master" alt="Build Status"></a></p>

<p>This R package implements our method for automatically generating models of dynamic decision-making that both have strong predictive power and are interpretable in human terms. This is useful for designing empirically grounded agent-based simulations and for gaining direct insight into observed dynamic processes. We use an efficient model representation and a genetic algorithm-based estimation process to generate simple deterministic approximations that explain most of the structure of complex stochastic processes. The GA is implemented with the GA package (<a href="http://www.jstatsoft.org/v53/i04/">Scrucca 2013</a>). Our method, implemented in C++ and R, scales well to large data sets. We have applied the package to empirical data, and demonstrated the method's ability to recover known data-generating processes by simulating data with agent-based models and correctly deriving the underlying decision models for multiple agent models and degrees of stochasticity.</p>

<p>A user of our package can estimate models by providing their data in a common "panel data" matrix format. The package is designed to estimate any time series classification model that uses a small number of binary predictor variables and moves back and forth between the values of the outcome variable over time. Larger sets of predictor variables can be reduced to smaller sets with cross-validation. Although the predictor variables must be binary, a quantitative variable can be converted into binary by division of the observed values into high/low classes. Future releases of the package may include additional estimation methods to complement genetic algorithm optimization.</p>

<p>If you use this package, cite: "Nay, J., Gilligan, J. 2015. Data-Driven Dynamic Decision Models. Proceedings of the 2015 Winter Simulation Conference".</p>

<p>This work is supported by U.S. National Science Foundation grants EAR-1416964 and EAR-1204685.</p>

<p>Install and load the latest release of the package from GitHub using the <code>devtools</code> package:</p>

<div class="highlight highlight-r"><pre>install.packages(<span class="pl-s"><span class="pl-pds">"</span>devtools<span class="pl-pds">"</span></span>)
<span class="pl-e">devtools</span><span class="pl-k">::</span>install_github(<span class="pl-s"><span class="pl-pds">"</span>JohnNay/datafsm<span class="pl-pds">"</span></span>)
library(<span class="pl-smi">datafsm</span>)</pre></div>

<p>To show how it works, create fake data:</p>

<div class="highlight highlight-r"><pre><span class="pl-smi">cdata</span> <span class="pl-k">&lt;-</span> <span class="pl-k">data.frame</span>(<span class="pl-v">period</span> <span class="pl-k">=</span> rep(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>, <span class="pl-c1">1000</span>),
                    <span class="pl-v">outcome</span> <span class="pl-k">=</span> rep(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">2</span>, <span class="pl-c1">5000</span>),
                    <span class="pl-v">my.decision1</span> <span class="pl-k">=</span> sample(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">0</span>, <span class="pl-c1">10000</span>, <span class="pl-c1">TRUE</span>),
                    <span class="pl-v">other.decision1</span> <span class="pl-k">=</span> sample(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">0</span>, <span class="pl-c1">10000</span>, <span class="pl-c1">TRUE</span>))</pre></div>

<p>Estimate a model with that data:</p>

<div class="highlight highlight-r"><pre><span class="pl-smi">result</span> <span class="pl-k">&lt;-</span> evolve_model(<span class="pl-smi">cdata</span>)</pre></div>

<p>Use the summary and plot methods on the output of the <code>evolve_model()</code> function:</p>

<div class="highlight highlight-r"><pre>summary(<span class="pl-smi">result</span>)
<span class="pl-c">#&gt;                                     </span>
<span class="pl-c">#&gt; Gentic Algorithm Settings: </span>
<span class="pl-c">#&gt; Population size       =  75 </span>
<span class="pl-c">#&gt; Number of generations =  150 </span>
<span class="pl-c">#&gt; Elitism               =  4 </span>
<span class="pl-c">#&gt; Crossover probability =  0.8 </span>
<span class="pl-c">#&gt; Mutation probability  =  0.1 </span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; Finite State Machine Settings: </span>
<span class="pl-c">#&gt; Actions =  2 </span>
<span class="pl-c">#&gt; States  =  2 </span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; Results: </span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; Iterations For This Run              = 6 </span>
<span class="pl-c">#&gt; Training Data Fitness Function Value = 1 </span>
<span class="pl-c">#&gt; Test Data Fitness Function Value     = No test data provided. Provide some to get more accurate estimation of generalization power. </span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; (Bit String Form) of Solution: </span>
<span class="pl-c">#&gt;  x1  x2  x3  x4  x5  x6  x7  x8  x9 x10 </span>
<span class="pl-c">#&gt;   0   1   1   1   1   1   1   1   1   1 </span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; State Matrix of Solution: </span>
<span class="pl-c">#&gt;      my.decision1FALSE:other.decision1FALSE</span>
<span class="pl-c">#&gt; [1,]                                      2</span>
<span class="pl-c">#&gt; [2,]                                      1</span>
<span class="pl-c">#&gt;      my.decision1TRUE:other.decision1FALSE</span>
<span class="pl-c">#&gt; [1,]                                     2</span>
<span class="pl-c">#&gt; [2,]                                     1</span>
<span class="pl-c">#&gt;      my.decision1FALSE:other.decision1TRUE</span>
<span class="pl-c">#&gt; [1,]                                     2</span>
<span class="pl-c">#&gt; [2,]                                     1</span>
<span class="pl-c">#&gt;      my.decision1TRUE:other.decision1TRUE</span>
<span class="pl-c">#&gt; [1,]                                    2</span>
<span class="pl-c">#&gt; [2,]                                    1</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; Action Vector of Solution: </span>
<span class="pl-c">#&gt; [1] 1 2</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; Variable Importance: </span>
<span class="pl-c">#&gt; my.decision1FALSE:other.decision1FALSE </span>
<span class="pl-c">#&gt;                                   96.9 </span>
<span class="pl-c">#&gt;  my.decision1TRUE:other.decision1FALSE </span>
<span class="pl-c">#&gt;                                   98.3 </span>
<span class="pl-c">#&gt;  my.decision1FALSE:other.decision1TRUE </span>
<span class="pl-c">#&gt;                                  100.0 </span>
<span class="pl-c">#&gt;   my.decision1TRUE:other.decision1TRUE </span>
<span class="pl-c">#&gt;                                   96.3</span>
plot(<span class="pl-smi">result</span>, <span class="pl-v">action_label</span> <span class="pl-k">=</span> c(<span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>))</pre></div>

<p><img src="README-unnamed-chunk-6-1.png" alt=""></p>

<p>Check out the documentation for the main function of the package to learn about all the options:</p>

<div class="highlight highlight-r"><pre>?<span class="pl-smi">evolve_model</span>
<span class="pl-c">#&gt; Use a Genetic Algorithm to Estimate a Finite-state Machine Model</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; Description:</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;      'evolve_model' uses a genetic algorithm to estimate a finite-state</span>
<span class="pl-c">#&gt;      machine model, primarily for understanding and predicting</span>
<span class="pl-c">#&gt;      decision-making.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; Usage:</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;      evolve_model(data, test_data = NULL, drop_nzv = FALSE,</span>
<span class="pl-c">#&gt;        measure = c("accuracy", "sens", "spec", "ppv"), states = 2, cv = FALSE,</span>
<span class="pl-c">#&gt;        max_states = 3, k = 2, actions = NULL, seed = NULL, popSize = 75,</span>
<span class="pl-c">#&gt;        pcrossover = 0.8, pmutation = 0.1, maxiter = 50, run = 25,</span>
<span class="pl-c">#&gt;        parallel = FALSE, priors = NULL, verbose = TRUE)</span>
<span class="pl-c">#&gt;      </span>
<span class="pl-c">#&gt; Arguments:</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;     data: data.frame that has columns named "period" and "outcome"</span>
<span class="pl-c">#&gt;           (period is the time period that the outcome action was</span>
<span class="pl-c">#&gt;           taken), and the rest of the columns are predictors, ranging</span>
<span class="pl-c">#&gt;           from one to three predictors. All of the (3-5 columns) should</span>
<span class="pl-c">#&gt;           be named. The period and outcome columns should be integer</span>
<span class="pl-c">#&gt;           vectors and the columns with the predictor variable data</span>
<span class="pl-c">#&gt;           should be logical vectors ('TRUE, FALSE'). If the predictor</span>
<span class="pl-c">#&gt;           variable data is not logical, it will coerced to logical with</span>
<span class="pl-c">#&gt;           'base::as.logical()'.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; test_data: Optional data.frame that has "period" and "outcome" columns</span>
<span class="pl-c">#&gt;           and rest of columns are predictors, ranging from one to three</span>
<span class="pl-c">#&gt;           predictors. All of the (3-5 columns) should be named. Outcome</span>
<span class="pl-c">#&gt;           variable is the decision the decision-maker took for that</span>
<span class="pl-c">#&gt;           period. This data.frame should be in the same format and have</span>
<span class="pl-c">#&gt;           the same order of columns as the data.frame passed to the</span>
<span class="pl-c">#&gt;           required 'data' argument.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; drop_nzv: Optional logical vector length one specifying whether</span>
<span class="pl-c">#&gt;           predictors variables with variance in provided data near zero</span>
<span class="pl-c">#&gt;           should be dropped before model building. Default is 'FALSE'.</span>
<span class="pl-c">#&gt;           See 'caret::nearZeroVar()', which calls: 'caret::nzv()'.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;  measure: Optional length one character vector that is either:</span>
<span class="pl-c">#&gt;           "accuracy", "sens", "spec", or "ppv". This specifies what</span>
<span class="pl-c">#&gt;           measure of predictive performance to use for training and</span>
<span class="pl-c">#&gt;           evaluating the model. The default measure is '"accuracy"'.</span>
<span class="pl-c">#&gt;           However, accuracy can be a problematic measure when the</span>
<span class="pl-c">#&gt;           classes are imbalanced in the samples, i.e. if a class the</span>
<span class="pl-c">#&gt;           model is trying to predict is very rare. Alternatives to</span>
<span class="pl-c">#&gt;           accuracy are available that illuminate different aspects of</span>
<span class="pl-c">#&gt;           predictive power. Sensitivity answers the question, `` given</span>
<span class="pl-c">#&gt;           that a result is truly an event, what is the probability that</span>
<span class="pl-c">#&gt;           the model will predict an event?'' Specificity answers the</span>
<span class="pl-c">#&gt;           question, ``given that a result is truly not an event, what</span>
<span class="pl-c">#&gt;           is the probability that the model will predict a negative?''</span>
<span class="pl-c">#&gt;           Positive predictive value answers, ``what is the percent of</span>
<span class="pl-c">#&gt;           predicted positives that are actually positive?''</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;   states: Optional numeric vector with the number of states. Default is</span>
<span class="pl-c">#&gt;           '2'.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;       cv: Optional logical vector length one for whether</span>
<span class="pl-c">#&gt;           cross-validation should be conducted on training data to</span>
<span class="pl-c">#&gt;           select optimal number of states. This can drastically</span>
<span class="pl-c">#&gt;           increase computation time because if 'TRUE', it will run</span>
<span class="pl-c">#&gt;           evolve_model k*max_states times to estimate optimal value for</span>
<span class="pl-c">#&gt;           states. Ties are broken by choosing the smaller number of</span>
<span class="pl-c">#&gt;           states. Default is 'FALSE'.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; max_states: Optional numeric vector length one only relevant if</span>
<span class="pl-c">#&gt;           'cv==TRUE'. It specifies how up to how many states that</span>
<span class="pl-c">#&gt;           cross-validation should search through. Default is '3'.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;        k: Optional numeric vector length one only relevant if cv==TRUE,</span>
<span class="pl-c">#&gt;           specifying number of folds for cross-validation.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;  actions: Optional numeric vector with the number of actions. If not</span>
<span class="pl-c">#&gt;           provided, then actions will be set as the number of unique</span>
<span class="pl-c">#&gt;           values in the outcome vector.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;     seed: Optional numeric vector length one.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;  popSize: Optional numeric vector length one specifying the size of the</span>
<span class="pl-c">#&gt;           GA population. A larger number will increase the probability</span>
<span class="pl-c">#&gt;           of finding a very good solution but will also increase the</span>
<span class="pl-c">#&gt;           computation time. This is passed to the GA::ga() function of</span>
<span class="pl-c">#&gt;           the *GA* package.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; pcrossover: Optional numeric vector length one specifying probability</span>
<span class="pl-c">#&gt;           of crossover for GA. This is passed to the GA::ga() function</span>
<span class="pl-c">#&gt;           of the *GA* package.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; pmutation: Optional numeric vector length one specifying probability of</span>
<span class="pl-c">#&gt;           mutation for GA. This is passed to the GA::ga() function of</span>
<span class="pl-c">#&gt;           the *GA* package.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;  maxiter: Optional numeric vector length one specifying max number of</span>
<span class="pl-c">#&gt;           iterations for stopping the GA evolution. A larger number</span>
<span class="pl-c">#&gt;           will increase the probability of finding a very good solution</span>
<span class="pl-c">#&gt;           but will also increase the computation time. This is passed</span>
<span class="pl-c">#&gt;           to the GA::ga() function of the *GA* package. maxiter scaled</span>
<span class="pl-c">#&gt;           by how many parameters are in the model: maxiter +</span>
<span class="pl-c">#&gt;           ((maxiter*(nBits^2)) / maxiter).</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;      run: Optional numeric vector length one specifying max number of</span>
<span class="pl-c">#&gt;           consecutive iterations without improvement in best fitness</span>
<span class="pl-c">#&gt;           score for stopping the GA evolution. A larger number will</span>
<span class="pl-c">#&gt;           increase the probability of finding a very good solution but</span>
<span class="pl-c">#&gt;           will also increase the computation time. This is passed to</span>
<span class="pl-c">#&gt;           the GA::ga() function of the *GA* package.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; parallel: Optional logical vector length one. For running the GA</span>
<span class="pl-c">#&gt;           evolution in parallel. Depending on the number of cores</span>
<span class="pl-c">#&gt;           registered and the memory on your machine, this can make the</span>
<span class="pl-c">#&gt;           process much faster, but only works for Unix-based machines</span>
<span class="pl-c">#&gt;           that can fork the processes.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;   priors: Optional numeric matrix of solutions strings to be included</span>
<span class="pl-c">#&gt;           in the initialization. User needs to use a decoder function</span>
<span class="pl-c">#&gt;           to translate prior decision models into bits and then provide</span>
<span class="pl-c">#&gt;           them. If this is not specified, then random priors are</span>
<span class="pl-c">#&gt;           automatically created.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;  verbose: Optional logical vector length one specifying whether helpful</span>
<span class="pl-c">#&gt;           messages should be displayed on the user's console or not.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; Details:</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;      This is the main function of the *datafsm* package. It relies on</span>
<span class="pl-c">#&gt;      the *GA* package for genetic algorithm optimization.</span>
<span class="pl-c">#&gt;      'evolve_model' takes data on predictors and data on the outcome.</span>
<span class="pl-c">#&gt;      It automatically creates a fitness function that takes the data,</span>
<span class="pl-c">#&gt;      an action vector 'evolve_model' generates, and a state matrix</span>
<span class="pl-c">#&gt;      'evolve_model' generates as input and returns numeric vector of</span>
<span class="pl-c">#&gt;      the same length as the 'outcome'. 'evolve_model' then computes a</span>
<span class="pl-c">#&gt;      fitness score for that potential solution FSM by comparing it to</span>
<span class="pl-c">#&gt;      the provided 'outcome'. This is repeated for every FSM in the</span>
<span class="pl-c">#&gt;      population and then the probability of selection for the next</span>
<span class="pl-c">#&gt;      generation is proportional to the fitness scores. The default is</span>
<span class="pl-c">#&gt;      also for the function to call itself recursively while varying the</span>
<span class="pl-c">#&gt;      number of states inside a cross-validation loop in order to</span>
<span class="pl-c">#&gt;      estimate the optimal number of states.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;      If parallel is set to TRUE, then these evaluations are distributed</span>
<span class="pl-c">#&gt;      across the available processors of the computer using the</span>
<span class="pl-c">#&gt;      *doParallel* package, otherwise, the evalulations of fitness are</span>
<span class="pl-c">#&gt;      conducted sequentially. Because this fitness function that</span>
<span class="pl-c">#&gt;      'evolve_model' creates must loop through all the data everytime it</span>
<span class="pl-c">#&gt;      is evaluated and we need to evaluate many possible solution FSMs,</span>
<span class="pl-c">#&gt;      the fitness function is implemented in C++ so it is very fast.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;      'evolve_model' uses a stochastic meta-heuristic optimization</span>
<span class="pl-c">#&gt;      routine to estimate the parameters that define a FSM model.</span>
<span class="pl-c">#&gt;      Generalized simulated annealing, or tabu search could work, but</span>
<span class="pl-c">#&gt;      they are more difficult to parallelize. The current version uses</span>
<span class="pl-c">#&gt;      the *GA* package's genetic algorithm because GAs perform well in</span>
<span class="pl-c">#&gt;      rugged search spaces to solve integer optimization problems, are a</span>
<span class="pl-c">#&gt;      natural complement to our binary string representation of FSMs,</span>
<span class="pl-c">#&gt;      and are easily parallelized.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;      This function evolves the models on training data and then, if a</span>
<span class="pl-c">#&gt;      test set is provided, uses the best solution to make predictions</span>
<span class="pl-c">#&gt;      on test data. Finally, the function returns the GA object and the</span>
<span class="pl-c">#&gt;      decoded version of the best string in the population. See ga_fsm</span>
<span class="pl-c">#&gt;      for the details of the slots (objects) that this type of object</span>
<span class="pl-c">#&gt;      will have.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; Value:</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;      Returns an S4 object of class ga_fsm. See ga_fsm for the details</span>
<span class="pl-c">#&gt;      of the slots (objects) that this type of object will have and for</span>
<span class="pl-c">#&gt;      information on the methods that can be used to summarize the</span>
<span class="pl-c">#&gt;      calling and execution of 'evolve_model()', including 'summary',</span>
<span class="pl-c">#&gt;      'print', and 'plot'. Timing measurement is in seconds.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; References:</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;      Luca Scrucca (2013). GA: A Package for Genetic Algorithms in R.</span>
<span class="pl-c">#&gt;      Journal of Statistical Software, 53(4), 1-37. URL</span>
<span class="pl-c">#&gt;      http://www.jstatsoft.org/v53/i04/.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; Examples:</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;      # Create data:</span>
<span class="pl-c">#&gt;      cdata &lt;- data.frame(period = rep(1:10, 1000),</span>
<span class="pl-c">#&gt;                         outcome = rep(1:2, 5000),</span>
<span class="pl-c">#&gt;                         my.decision1 = sample(1:0, 10000, TRUE),</span>
<span class="pl-c">#&gt;                         other.decision1 = sample(1:0, 10000, TRUE))</span>
<span class="pl-c">#&gt;      (res &lt;- evolve_model(cdata, cv=FALSE))</span>
<span class="pl-c">#&gt;      summary(res)</span>
<span class="pl-c">#&gt;      plot(res, action_label = c("C", "D"))</span>
<span class="pl-c">#&gt;      library(GA)</span>
<span class="pl-c">#&gt;      plot(estimation_details(res))</span>
<span class="pl-c">#&gt;      </span>
<span class="pl-c">#&gt;      # In scripts, it can makes sense to set parallel to</span>
<span class="pl-c">#&gt;      # 'as.logical(Sys.info()['sysname'] != 'Windows')'.</span>
<span class="pl-c">#&gt; </span></pre></div>
        </article>
      </div>
    </div>
    <footer>
      <div class="owner">
      <p><a href="https://github.com/JohnNay" class="avatar"><img src="https://avatars0.githubusercontent.com/u/8429627?v=3&amp;s=60" width="48" height="48"></a> <a href="https://github.com/JohnNay">JohnNay</a> maintains <a href="https://github.com/JohnNay/datafsm">datafsm</a></p>


      </div>
      <div class="creds">
        <small>This page generated using <a href="https://pages.github.com/">GitHub Pages</a><br>theme by <a href="https://twitter.com/jonrohan/">Jon Rohan</a></small>
      </div>
    </footer>
  </div>
  <div class="current-section">
    <a href="#top">Scroll to top</a>
    <a href="https://github.com/JohnNay/datafsm/tarball/master" class="tar">tar</a><a href="https://github.com/JohnNay/datafsm/zipball/master" class="zip">zip</a><a href="" class="code">source code</a>
    <p class="name"></p>
  </div>

  
</body>
</html>
