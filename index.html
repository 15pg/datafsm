<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>datafsm by JohnNay</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">datafsm</h1>
      <h2 class="project-tagline">Estimating Finite State Machine Models from Data</h2>
      <a href="https://github.com/JohnNay/datafsm" class="btn">View on GitHub</a>
      <a href="https://github.com/JohnNay/datafsm/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/JohnNay/datafsm/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      

<p><a href="https://travis-ci.org/JohnNay/datafsm"><img src="https://travis-ci.org/JohnNay/datafsm.png?branch=master" alt="Build Status"></a></p>

<p>This package implements our method for automatically generating models of dynamic decision-making that both have strong predictive power and are interpretable in human terms. We use an efficient model representation and a genetic algorithm-based estimation process to generate simple deterministic approximations that explain most of the structure of complex stochastic processes. The genetic algorithm is implemented with the <strong>GA</strong> package (<a href="http://www.jstatsoft.org/v53/i04/">Scrucca 2013</a>). Our method, implemented in C++ and R, scales well to large data sets. We have applied the package to empirical data, and demonstrated the method's ability to recover known data-generating processes by simulating data with agent-based models and correctly deriving the underlying decision models for multiple agent models and degrees of stochasticity.</p>

<p>A user of our package can estimate models by providing their data in a common "panel data" format. The package is designed to estimate time series classification models that use a small number of binary predictor variables and move back and forth between the values of the outcome variable over time. Larger sets of predictor variables can be reduced to smaller sets with cross-validation. Although the predictor variables must be binary, a quantitative variable can be converted into binary by division of the observed values into high/low classes. Future releases of the package may include additional estimation methods to complement genetic algorithm optimization.</p>

<div class="highlight highlight-r"><pre><span class="pl-c"># Load and attach datafsm into your R session, making its functions available:</span>
library(<span class="pl-smi">datafsm</span>)</pre></div>

<p>Please cite the package if you use it with the text generated by:</p>

<div class="highlight highlight-r"><pre>citation(<span class="pl-s"><span class="pl-pds">"</span>datafsm<span class="pl-pds">"</span></span>)
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; To cite datafsm in publications use:</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;   John J. Nay, Jonathan M. Gilligan (2015) "Data-Driven Dynamic</span>
<span class="pl-c">#&gt;   Decision Models," in L. Yilmaz et al. (eds.), Proc. 2015 Winter</span>
<span class="pl-c">#&gt;   Simulation Conf.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; A BibTeX entry for LaTeX users is</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;   @InProceedings{,</span>
<span class="pl-c">#&gt;     title = {Data-Driven Dynamic Decision Models},</span>
<span class="pl-c">#&gt;     author = {John J. Nay and Jonathan M. Gilligan},</span>
<span class="pl-c">#&gt;     booktitle = {Proceedings of the 2015 Winter Simulation Conference},</span>
<span class="pl-c">#&gt;     year = {2015},</span>
<span class="pl-c">#&gt;     editor = {L. Yilmaz and W.K.V. Chan and I. Moon and T.M.K. Roeder and C. Macal and M. Rosetti},</span>
<span class="pl-c">#&gt;   }</span></pre></div>

<h1>
<a id="fake-data-example" class="anchor" href="#fake-data-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fake Data Example</h1>

<p>To quickly show it works, we can create fake data. Here, we generate 1000 repetitions of a ten-round game in which each player starts by making a random move, and in subsequent rounds, one player follows a "tit-for-tat" strategy while the other one follows a "noisy tit-for-tat" strategy that's equivalent to tit-for-tat, except that with a 10% probability the player will make a random move.</p>

<div class="highlight highlight-r"><pre><span class="pl-smi">cdata</span> <span class="pl-k">&lt;-</span> <span class="pl-k">data.frame</span>(<span class="pl-v">period</span> <span class="pl-k">=</span> rep(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>, <span class="pl-c1">1000</span>),
                    <span class="pl-v">outcome</span> <span class="pl-k">=</span> <span class="pl-c1">NA</span>,
                    <span class="pl-v">my.decision1</span> <span class="pl-k">=</span> <span class="pl-c1">NA</span>,
                    <span class="pl-v">other.decision1</span> <span class="pl-k">=</span> <span class="pl-c1">NA</span>)
<span class="pl-c">#</span>
<span class="pl-c"># Prisoner's dilemma</span>
<span class="pl-c">#</span>
<span class="pl-en">pd_outcome</span> <span class="pl-k">&lt;-</span> <span class="pl-k">function</span>(<span class="pl-smi">player_1</span>, <span class="pl-smi">player_2</span>) {
  <span class="pl-c">#</span>
  <span class="pl-c"># 1 = C</span>
  <span class="pl-c"># 2 = D</span>
  <span class="pl-c">#</span>
  <span class="pl-smi">player_1</span>  <span class="pl-k">+</span> <span class="pl-c1">1</span>
}

<span class="pl-en">tit_for_tat</span> <span class="pl-k">&lt;-</span> <span class="pl-k">function</span>(<span class="pl-smi">last_round_self</span>, <span class="pl-smi">last_round_opponent</span>) {
    <span class="pl-smi">last_round_opponent</span>
}

<span class="pl-en">noisy_tit_for_tat</span> <span class="pl-k">&lt;-</span> <span class="pl-k">function</span>(<span class="pl-smi">last_round_self</span>, <span class="pl-smi">last_round_opponent</span>) {
  <span class="pl-k">if</span> (runif(<span class="pl-c1">1</span>,<span class="pl-c1">0</span>,<span class="pl-c1">1</span>) <span class="pl-k">&lt;</span><span class="pl-k">=</span> <span class="pl-c1">0.1</span>) {
    sample(<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">1</span>)
  } <span class="pl-k">else</span> {
    <span class="pl-smi">last_round_opponent</span>
  }
}

<span class="pl-k">for</span> (<span class="pl-smi">i</span> <span class="pl-k">in</span> seq_along(<span class="pl-smi">cdata</span><span class="pl-k">$</span><span class="pl-smi">period</span>)) {
  <span class="pl-k">if</span> (<span class="pl-smi">cdata</span><span class="pl-k">$</span><span class="pl-smi">period</span>[<span class="pl-smi">i</span>] <span class="pl-k">==</span> <span class="pl-c1">1</span>) {
    <span class="pl-smi">my.decision</span> <span class="pl-k">&lt;-</span> sample(<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">1</span>)
    <span class="pl-smi">other.decision</span> <span class="pl-k">&lt;-</span> sample(<span class="pl-c1">0</span><span class="pl-k">:</span><span class="pl-c1">1</span>,<span class="pl-c1">1</span>)
  } <span class="pl-k">else</span>{
    <span class="pl-smi">my.last</span> <span class="pl-k">&lt;-</span> <span class="pl-smi">my.decision</span>
    <span class="pl-smi">other.last</span> <span class="pl-k">&lt;-</span> <span class="pl-smi">other.decision</span>
    <span class="pl-smi">my.decision</span> <span class="pl-k">&lt;-</span> tit_for_tat(<span class="pl-smi">my.last</span>, <span class="pl-smi">other.last</span>)
    <span class="pl-smi">other.decision</span> <span class="pl-k">&lt;-</span> noisy_tit_for_tat(<span class="pl-smi">other.last</span>, <span class="pl-smi">my.last</span>)
  }
  <span class="pl-smi">cdata</span>[<span class="pl-smi">i</span>,<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">&lt;-</span> c(pd_outcome(<span class="pl-smi">my.decision</span>, <span class="pl-smi">other.decision</span>), <span class="pl-smi">my.decision</span>, <span class="pl-smi">other.decision</span>)
}</pre></div>

<p>The only required argument of the main function of the package, <code>evolve_model</code>, is a <code>data.frame</code> object, which must have 3-5 columns. The first two columns must be named "period" and "outcome" (period is the time period that the outcome action was taken). The remaining one to three columns are predictors, and may have arbitrary names. Each row of the <code>data.frame</code> is an observational unit, an action taken at a particular time and any relevant variables for that time. All of the (3-5 columns) should be named. The period and outcome columns should be integer vectors --- e.g. <code>c(1,2,1)</code> --- and the columns with the predictor variable data should be logical vectors --- e.g. <code>c(TRUE, FALSE, FALSE)</code> --- or vectors that can be coerced to logical with <code>as.logical()</code>.</p>

<p>Here are the first eleven rows of this fake data:</p>

<table>
<thead>
<tr>
<th align="right">period</th>
<th align="right">outcome</th>
<th align="right">my.decision1</th>
<th align="right">other.decision1</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
<tr>
<td align="right">2</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr>
<td align="right">3</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
<tr>
<td align="right">4</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr>
<td align="right">5</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
<tr>
<td align="right">6</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr>
<td align="right">7</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
<tr>
<td align="right">8</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr>
<td align="right">9</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
<tr>
<td align="right">10</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr>
<td align="right">1</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
</tbody>
</table>

<p>We can estimate a model with that data. <code>evolve_model</code> uses a genetic algorithm to estimate a finite-state machine (FSM) model, primarily for understanding and predicting decision-making. This is the main function of the <code>datafsm</code> package. It relies on the <code>GA</code> package for genetic algorithm optimization. We chose to use a GA because GAs perform well in rugged search spaces to solve integer optimization problems, are a natural complement to our binary representation of FSMs, and are easily parallelized.</p>

<p><code>evolve_model</code> takes data on predictors and data on the outcome and automatically creates a fitness function that takes training data, an action vector that <code>evolve_model</code> generates, and a state matrix <code>evolve_model</code> generates as input and returns numeric vector whose length is the number of rows in the training data. <code>evolve_model</code> then computes a fitness score for that potential solution FSM by comparing it to the provided <code>outcome</code> in the real training data. This is repeated for every FSM in the population and then the probability of selection for the next generation is proportional to the fitness scores. If the argument <code>cv</code> is set to <code>TRUE</code> the function will call itself recursively while varying the number of states inside a cross-validation loop in order to estimate the optimal number of states, then it will set the number of states to that optimal number and estimate the model on the full training set.</p>

<p>If the argument <code>parallel</code> is set to <code>TRUE</code>, then these evaluations are distributed across the available processors of the computer using the <code>doParallel</code> functions; otherwise, the evalulations of fitness are conducted sequentially. Because this fitness function that <code>evolve_model</code> creates must loop through all the training data everytime it is evaluated and we need to evaluate many possible solution FSMs, the fitness function is implemented in C++ to improve its performance.</p>

<div class="highlight highlight-r"><pre><span class="pl-smi">res</span> <span class="pl-k">&lt;-</span> evolve_model(<span class="pl-smi">cdata</span>)</pre></div>

<p><code>evolve_model</code> evolves the models on training data and then, if a test set is provided, uses the best solution to make predictions on test data. Finally, the function returns the GA object and the decoded version of the best string in the population. Formally, the function return an <code>S4</code> object with slots for:</p>

<ul>
<li>  <code>call</code> Language from the call of the function.</li>
<li>  <code>actions</code> Numeric vector with the number of actions.</li>
<li>  <code>states</code> Numeric vector with the number of states.</li>
<li>  <code>GA</code> S4 object created by <code>ga()</code> from the <code>GA</code> package.</li>
<li>  <code>state_mat</code> Numeric matrix with rows as states and columns as predictors.</li>
<li>  <code>action_vec</code> Numeric vector indicating what action to take for each state.</li>
<li>  <code>predictive</code> Numeric vector of length one with test data accuracy if test data was supplied; otherwise, a character vector with a message that the user should provide test data for better estimate of generalizable performance.</li>
<li>  <code>varImp</code> Numeric vector with length equal to the number of columns in the state matrix, containing relative importance scores for each predictor.</li>
<li>  <code>timing</code> Numeric vector length one containing the total elapsed time it took <code>evolve_model</code> to execute.</li>
<li>  <code>diagnostics</code> Character vector length one, designed to be printed with <code>base::cat()</code>.</li>
</ul>

<p>Use the summary and plot methods on the output of the <code>evolve_model()</code> function:</p>

<div class="highlight highlight-r"><pre>summary(<span class="pl-smi">res</span>)
<span class="pl-c">#&gt;                                     </span>
<span class="pl-c">#&gt; Gentic Algorithm Settings: </span>
<span class="pl-c">#&gt; Population size       =  75 </span>
<span class="pl-c">#&gt; Number of generations =  150 </span>
<span class="pl-c">#&gt; Elitism               =  4 </span>
<span class="pl-c">#&gt; Crossover probability =  0.8 </span>
<span class="pl-c">#&gt; Mutation probability  =  0.1 </span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; Finite State Machine Settings: </span>
<span class="pl-c">#&gt; Actions =  2 </span>
<span class="pl-c">#&gt; States  =  2 </span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; Results: </span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; Iterations For This Run              = 31 </span>
<span class="pl-c">#&gt; Training Data Fitness Function Value = 0.951 </span>
<span class="pl-c">#&gt; Test Data Fitness Function Value     = No test data provided. Provide some to get more accurate estimation of generalization power. </span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; (Bit String Form) of Solution: </span>
<span class="pl-c">#&gt;  x1  x2  x3  x4  x5  x6  x7  x8  x9 x10 </span>
<span class="pl-c">#&gt;   0   1   0   0   1   0   1   0   1   0 </span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; State Matrix of Solution: </span>
<span class="pl-c">#&gt;      my.decision1FALSE:other.decision1FALSE</span>
<span class="pl-c">#&gt; [1,]                                      1</span>
<span class="pl-c">#&gt; [2,]                                      1</span>
<span class="pl-c">#&gt;      my.decision1TRUE:other.decision1FALSE</span>
<span class="pl-c">#&gt; [1,]                                     2</span>
<span class="pl-c">#&gt; [2,]                                     2</span>
<span class="pl-c">#&gt;      my.decision1FALSE:other.decision1TRUE</span>
<span class="pl-c">#&gt; [1,]                                     1</span>
<span class="pl-c">#&gt; [2,]                                     1</span>
<span class="pl-c">#&gt;      my.decision1TRUE:other.decision1TRUE</span>
<span class="pl-c">#&gt; [1,]                                    2</span>
<span class="pl-c">#&gt; [2,]                                    2</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; Action Vector of Solution: </span>
<span class="pl-c">#&gt; [1] 1 2</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; Variable Importance: </span>
<span class="pl-c">#&gt; my.decision1FALSE:other.decision1FALSE </span>
<span class="pl-c">#&gt;                                   52.6 </span>
<span class="pl-c">#&gt;  my.decision1TRUE:other.decision1FALSE </span>
<span class="pl-c">#&gt;                                   82.1 </span>
<span class="pl-c">#&gt;  my.decision1FALSE:other.decision1TRUE </span>
<span class="pl-c">#&gt;                                   81.9 </span>
<span class="pl-c">#&gt;   my.decision1TRUE:other.decision1TRUE </span>
<span class="pl-c">#&gt;                                  100.0</span>
plot(<span class="pl-smi">res</span>, <span class="pl-v">action_label</span> <span class="pl-k">=</span> c(<span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>), <span class="pl-v">transition_label</span> <span class="pl-k">=</span> c(<span class="pl-s"><span class="pl-pds">'</span>cc<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>cd<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>dc<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>dd<span class="pl-pds">'</span></span>))</pre></div>

<p><img src="README-plot.fsm-1.png" alt="Result of `plot()` method call on `ga_fsm` object."></p>

<p>The diagram shows that <code>evolve_model</code> recovered a tit-for-tat model in which the player in question ("me") mimics the last action of the opponent.</p>

<p>Use the <code>estimation_details</code> method on the output of the <code>evolve_model()</code> function:</p>

<div class="highlight highlight-r"><pre>suppressMessages(library(<span class="pl-smi">GA</span>))
plot(estimation_details(<span class="pl-smi">res</span>))</pre></div>

<p><img src="README-plot.evolution-1.png" alt="Result of `plot()` method call on ga object, which is obtained by calling `estimation_details()` on `ga_fsm` object."></p>

<h1>
<a id="documentation-for-evolve_model" class="anchor" href="#documentation-for-evolve_model" aria-hidden="true"><span class="octicon octicon-link"></span></a>Documentation for <code>evolve_model</code>
</h1>

<p>Check out the documentation for the main function of the package to learn about all the options:</p>

<div class="highlight highlight-r"><pre>?<span class="pl-smi">evolve_model</span>
<span class="pl-c">#&gt; Use a Genetic Algorithm to Estimate a Finite-state Machine Model</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; Usage:</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;      evolve_model(data, test_data = NULL, drop_nzv = FALSE,</span>
<span class="pl-c">#&gt;        measure = c("accuracy", "sens", "spec", "ppv"), states = 2, cv = FALSE,</span>
<span class="pl-c">#&gt;        max_states = 3, k = 2, actions = NULL, seed = NULL, popSize = 75,</span>
<span class="pl-c">#&gt;        pcrossover = 0.8, pmutation = 0.1, maxiter = 50, run = 25,</span>
<span class="pl-c">#&gt;        parallel = FALSE, priors = NULL, verbose = TRUE)</span>
<span class="pl-c">#&gt;      </span>
<span class="pl-c">#&gt; Arguments:</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;     data: data.frame that has columns named "period" and "outcome"</span>
<span class="pl-c">#&gt;           (period is the time period that the outcome action was</span>
<span class="pl-c">#&gt;           taken), and the rest of the columns are predictors, ranging</span>
<span class="pl-c">#&gt;           from one to three predictors. All of the (3-5 columns) should</span>
<span class="pl-c">#&gt;           be named. The period and outcome columns should be integer</span>
<span class="pl-c">#&gt;           vectors and the columns with the predictor variable data</span>
<span class="pl-c">#&gt;           should be logical vectors ('TRUE, FALSE'). If the predictor</span>
<span class="pl-c">#&gt;           variable data is not logical, it will coerced to logical with</span>
<span class="pl-c">#&gt;           'base::as.logical()'.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; test_data: Optional data.frame that has "period" and "outcome" columns</span>
<span class="pl-c">#&gt;           and rest of columns are predictors, ranging from one to three</span>
<span class="pl-c">#&gt;           predictors. All of the (3-5 columns) should be named. Outcome</span>
<span class="pl-c">#&gt;           variable is the decision the decision-maker took for that</span>
<span class="pl-c">#&gt;           period. This data.frame should be in the same format and have</span>
<span class="pl-c">#&gt;           the same order of columns as the data.frame passed to the</span>
<span class="pl-c">#&gt;           required 'data' argument.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; drop_nzv: Optional logical vector length one specifying whether</span>
<span class="pl-c">#&gt;           predictors variables with variance in provided data near zero</span>
<span class="pl-c">#&gt;           should be dropped before model building. Default is 'FALSE'.</span>
<span class="pl-c">#&gt;           See 'caret::nearZeroVar()', which calls: 'caret::nzv()'.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;  measure: Optional length one character vector that is either:</span>
<span class="pl-c">#&gt;           "accuracy", "sens", "spec", or "ppv". This specifies what</span>
<span class="pl-c">#&gt;           measure of predictive performance to use for training and</span>
<span class="pl-c">#&gt;           evaluating the model. The default measure is '"accuracy"'.</span>
<span class="pl-c">#&gt;           However, accuracy can be a problematic measure when the</span>
<span class="pl-c">#&gt;           classes are imbalanced in the samples, i.e. if a class the</span>
<span class="pl-c">#&gt;           model is trying to predict is very rare. Alternatives to</span>
<span class="pl-c">#&gt;           accuracy are available that illuminate different aspects of</span>
<span class="pl-c">#&gt;           predictive power. Sensitivity answers the question, `` given</span>
<span class="pl-c">#&gt;           that a result is truly an event, what is the probability that</span>
<span class="pl-c">#&gt;           the model will predict an event?'' Specificity answers the</span>
<span class="pl-c">#&gt;           question, ``given that a result is truly not an event, what</span>
<span class="pl-c">#&gt;           is the probability that the model will predict a negative?''</span>
<span class="pl-c">#&gt;           Positive predictive value answers, ``what is the percent of</span>
<span class="pl-c">#&gt;           predicted positives that are actually positive?''</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;   states: Optional numeric vector with the number of states. Default is</span>
<span class="pl-c">#&gt;           '2'.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;       cv: Optional logical vector length one for whether</span>
<span class="pl-c">#&gt;           cross-validation should be conducted on training data to</span>
<span class="pl-c">#&gt;           select optimal number of states. This can drastically</span>
<span class="pl-c">#&gt;           increase computation time because if 'TRUE', it will run</span>
<span class="pl-c">#&gt;           evolve_model k*max_states times to estimate optimal value for</span>
<span class="pl-c">#&gt;           states. Ties are broken by choosing the smaller number of</span>
<span class="pl-c">#&gt;           states. Default is 'FALSE'.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; max_states: Optional numeric vector length one only relevant if</span>
<span class="pl-c">#&gt;           'cv==TRUE'. It specifies how up to how many states that</span>
<span class="pl-c">#&gt;           cross-validation should search through. Default is '3'.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;        k: Optional numeric vector length one only relevant if cv==TRUE,</span>
<span class="pl-c">#&gt;           specifying number of folds for cross-validation.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;  actions: Optional numeric vector with the number of actions. If not</span>
<span class="pl-c">#&gt;           provided, then actions will be set as the number of unique</span>
<span class="pl-c">#&gt;           values in the outcome vector.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;     seed: Optional numeric vector length one.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;  popSize: Optional numeric vector length one specifying the size of the</span>
<span class="pl-c">#&gt;           GA population. A larger number will increase the probability</span>
<span class="pl-c">#&gt;           of finding a very good solution but will also increase the</span>
<span class="pl-c">#&gt;           computation time. This is passed to the GA::ga() function of</span>
<span class="pl-c">#&gt;           the *GA* package.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; pcrossover: Optional numeric vector length one specifying probability</span>
<span class="pl-c">#&gt;           of crossover for GA. This is passed to the GA::ga() function</span>
<span class="pl-c">#&gt;           of the *GA* package.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; pmutation: Optional numeric vector length one specifying probability of</span>
<span class="pl-c">#&gt;           mutation for GA. This is passed to the GA::ga() function of</span>
<span class="pl-c">#&gt;           the *GA* package.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;  maxiter: Optional numeric vector length one specifying max number of</span>
<span class="pl-c">#&gt;           iterations for stopping the GA evolution. A larger number</span>
<span class="pl-c">#&gt;           will increase the probability of finding a very good solution</span>
<span class="pl-c">#&gt;           but will also increase the computation time. This is passed</span>
<span class="pl-c">#&gt;           to the GA::ga() function of the *GA* package. 'maxiter' is</span>
<span class="pl-c">#&gt;           scaled by how many parameters are in the model: 'maxiter &lt;-</span>
<span class="pl-c">#&gt;           maxiter + ((maxiter*(nBits^2)) / maxiter)'.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;      run: Optional numeric vector length one specifying max number of</span>
<span class="pl-c">#&gt;           consecutive iterations without improvement in best fitness</span>
<span class="pl-c">#&gt;           score for stopping the GA evolution. A larger number will</span>
<span class="pl-c">#&gt;           increase the probability of finding a very good solution but</span>
<span class="pl-c">#&gt;           will also increase the computation time. This is passed to</span>
<span class="pl-c">#&gt;           the GA::ga() function of the *GA* package.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; parallel: Optional logical vector length one. For running the GA</span>
<span class="pl-c">#&gt;           evolution in parallel. Depending on the number of cores</span>
<span class="pl-c">#&gt;           registered and the memory on your machine, this can make the</span>
<span class="pl-c">#&gt;           process much faster, but only works for Unix-based machines</span>
<span class="pl-c">#&gt;           that can fork the processes.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;   priors: Optional numeric matrix of solutions strings to be included</span>
<span class="pl-c">#&gt;           in the initialization. User needs to use a decoder function</span>
<span class="pl-c">#&gt;           to translate prior decision models into bits and then provide</span>
<span class="pl-c">#&gt;           them. If this is not specified, then random priors are</span>
<span class="pl-c">#&gt;           automatically created.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;  verbose: Optional logical vector length one specifying whether helpful</span>
<span class="pl-c">#&gt;           messages should be displayed on the user's console or not.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; Details:</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;      This is the main function of the *datafsm* package. It relies on</span>
<span class="pl-c">#&gt;      the *GA* package for genetic algorithm optimization.</span>
<span class="pl-c">#&gt;      'evolve_model' takes data on predictors and data on the outcome.</span>
<span class="pl-c">#&gt;      It automatically creates a fitness function that takes the data,</span>
<span class="pl-c">#&gt;      an action vector 'evolve_model' generates, and a state matrix</span>
<span class="pl-c">#&gt;      'evolve_model' generates as input and returns numeric vector of</span>
<span class="pl-c">#&gt;      the same length as the 'outcome'. 'evolve_model' then computes a</span>
<span class="pl-c">#&gt;      fitness score for that potential solution FSM by comparing it to</span>
<span class="pl-c">#&gt;      the provided 'outcome'. This is repeated for every FSM in the</span>
<span class="pl-c">#&gt;      population and then the probability of selection for the next</span>
<span class="pl-c">#&gt;      generation is proportional to the fitness scores. The default is</span>
<span class="pl-c">#&gt;      also for the function to call itself recursively while varying the</span>
<span class="pl-c">#&gt;      number of states inside a cross-validation loop in order to</span>
<span class="pl-c">#&gt;      estimate the optimal number of states.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;      If parallel is set to TRUE, then these evaluations are distributed</span>
<span class="pl-c">#&gt;      across the available processors of the computer using the</span>
<span class="pl-c">#&gt;      *doParallel* package, otherwise, the evalulations of fitness are</span>
<span class="pl-c">#&gt;      conducted sequentially. Because this fitness function that</span>
<span class="pl-c">#&gt;      'evolve_model' creates must loop through all the data everytime it</span>
<span class="pl-c">#&gt;      is evaluated and we need to evaluate many possible solution FSMs,</span>
<span class="pl-c">#&gt;      the fitness function is implemented in C++ so it is very fast.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;      'evolve_model' uses a stochastic meta-heuristic optimization</span>
<span class="pl-c">#&gt;      routine to estimate the parameters that define a FSM model.</span>
<span class="pl-c">#&gt;      Generalized simulated annealing, or tabu search could work, but</span>
<span class="pl-c">#&gt;      they are more difficult to parallelize. The current version uses</span>
<span class="pl-c">#&gt;      the *GA* package's genetic algorithm because GAs perform well in</span>
<span class="pl-c">#&gt;      rugged search spaces to solve integer optimization problems, are a</span>
<span class="pl-c">#&gt;      natural complement to our binary string representation of FSMs,</span>
<span class="pl-c">#&gt;      and are easily parallelized.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;      This function evolves the models on training data and then, if a</span>
<span class="pl-c">#&gt;      test set is provided, uses the best solution to make predictions</span>
<span class="pl-c">#&gt;      on test data. Finally, the function returns the GA object and the</span>
<span class="pl-c">#&gt;      decoded version of the best string in the population. See ga_fsm</span>
<span class="pl-c">#&gt;      for the details of the slots (objects) that this type of object</span>
<span class="pl-c">#&gt;      will have.</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; References:</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt;      Luca Scrucca (2013). GA: A Package for Genetic Algorithms in R.</span>
<span class="pl-c">#&gt;      Journal of Statistical Software, 53(4), 1-37. URL</span>
<span class="pl-c">#&gt;      http://www.jstatsoft.org/v53/i04/.</span></pre></div>

<h1>
<a id="acknowledgements" class="anchor" href="#acknowledgements" aria-hidden="true"><span class="octicon octicon-link"></span></a>Acknowledgements</h1>

<p>This work is supported by U.S. National Science Foundation grants EAR-1416964 and EAR-1204685.</p>

<h1>
<a id="session-info" class="anchor" href="#session-info" aria-hidden="true"><span class="octicon octicon-link"></span></a>Session Info</h1>

<div class="highlight highlight-r"><pre>sessionInfo()
<span class="pl-c">#&gt; R version 3.2.2 (2015-08-14)</span>
<span class="pl-c">#&gt; Platform: x86_64-apple-darwin13.4.0 (64-bit)</span>
<span class="pl-c">#&gt; Running under: OS X 10.10.5 (Yosemite)</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; locale:</span>
<span class="pl-c">#&gt; [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8</span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; attached base packages:</span>
<span class="pl-c">#&gt; [1] stats     graphics  grDevices utils     datasets  methods   base     </span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; other attached packages:</span>
<span class="pl-c">#&gt; [1] GA_2.2          iterators_1.0.7 foreach_1.4.2   datafsm_0.1.0  </span>
<span class="pl-c">#&gt; </span>
<span class="pl-c">#&gt; loaded via a namespace (and not attached):</span>
<span class="pl-c">#&gt;  [1] Rcpp_0.12.0         formatR_1.2         nloptr_1.0.4       </span>
<span class="pl-c">#&gt;  [4] plyr_1.8.3          highr_0.5           tools_3.2.2        </span>
<span class="pl-c">#&gt;  [7] digest_0.6.8        lme4_1.1-8          evaluate_0.7.2     </span>
<span class="pl-c">#&gt; [10] gtable_0.1.2        nlme_3.1-121        lattice_0.20-33    </span>
<span class="pl-c">#&gt; [13] mgcv_1.8-7          Matrix_1.2-2        yaml_2.1.13        </span>
<span class="pl-c">#&gt; [16] parallel_3.2.2      SparseM_1.7         brglm_0.5-9        </span>
<span class="pl-c">#&gt; [19] proto_0.3-10        BradleyTerry2_1.0-6 stringr_1.0.0      </span>
<span class="pl-c">#&gt; [22] knitr_1.10.5        gtools_3.5.0        stats4_3.2.2       </span>
<span class="pl-c">#&gt; [25] grid_3.2.2          caret_6.0-52        nnet_7.3-10        </span>
<span class="pl-c">#&gt; [28] diagram_1.6.3       rmarkdown_0.6.1     minqa_1.2.4        </span>
<span class="pl-c">#&gt; [31] ggplot2_1.0.1       reshape2_1.4.1      car_2.0-26         </span>
<span class="pl-c">#&gt; [34] magrittr_1.5        scales_0.2.5        codetools_0.2-14   </span>
<span class="pl-c">#&gt; [37] htmltools_0.2.6     MASS_7.3-43         splines_3.2.2      </span>
<span class="pl-c">#&gt; [40] pbkrtest_0.4-2      shape_1.4.2         colorspace_1.2-6   </span>
<span class="pl-c">#&gt; [43] quantreg_5.11       stringi_0.5-5       doParallel_1.0.8   </span>
<span class="pl-c">#&gt; [46] munsell_0.4.2</span></pre></div>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/JohnNay/datafsm">datafsm</a> is maintained by <a href="https://github.com/JohnNay">JohnNay</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
