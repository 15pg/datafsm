% Generated by roxygen2 (4.0.2): do not edit by hand
\name{evolve_model}
\alias{evolve_model}
\title{Uses a Genetic Algorithm to Estimate a Finite-state Machine}
\usage{
evolve_model(data, outcome, actions, states, seed, fitness_func, cols = NULL,
  test_data = NULL, test_outcome = NULL, popSize = 39, pcrossover = 0.8,
  pmutation = 0.1, maxiter = 20, run = 8, parallel = FALSE,
  priors = NULL, boltzmann = FALSE, alpha = 0.4)
}
\arguments{
\item{data}{Numeric matrix that has first col period and rest of cols are
predictors.}

\item{outcome}{Numeric vector same length as the number of rows as data.}

\item{actions}{Numeric vector with the number of actions.}

\item{states}{Numeric vector with the number of states.}

\item{seed}{Numeric vector length one.}

\item{fitness_func}{Function that takes data, action vector, and state matrix
as input and returns numeric vector of same length as the \code{outcome}. This
is then used inside \code{evolve_model} to compute a fitness score by comparing
it to the provided \code{outcome}.}
}
\value{
Returns an S4 object of class ga_fsm. See \linkS4class{ga_fsm} for
the details of the slots (objects) that this type of object will have and for
information on the methods that can be used to summarize the calling and
execution of \code{evolve_model()}, including \code{\link{summary.ga_fsm}}.
}
\description{
\code{evolve_model} uses a genetic algorithm to estimate a finite-state machine model.
}
\details{
This is the main function of the \strong{fsm} package. It takes data on predictors
and data on the outcome and then uses a stochastic meta-heuristic optimization
routine to estimate the parameter. Generalized simulated annealing could work.
The current version uses the \strong{GA} package's genetic algorithm
because GAs perform well in rugged search spaces to solve integer
optimization problems and are a natural complement to our binary string
representation of FSMs.
}
\examples{
\dontrun{
# create "fitnessC"
Rcpp::sourceCpp("/Users/johnnaymacbook/Documents/Rprojects/ga_fsm/genetic_abm/fitness.cpp")
# load data from fsm package
data(data); data (outcome)
# 80\% of the data for training
train_data <- data[1:108306, ]
train_outcome <- outcome[1:108306]
# 20\% of the data for testing
test_data <- data[108307:nrow(data), ]
test_outcome <- outcome[108307:nrow(data)]
evolved_models_empirical_data <- evolve_model(data = train_data, outcome = train_outcome,
                                              actions = 2, states = 2, seed = 13,
                                              fitness_func = fitnessC, cols = c(1, 2, 1, 2),
                                              test_data =  test_data, test_outcome = test_outcome,
                                              popSize = 175, maxiter = 55, run = 25, parallel = TRUE)
print(evolved_models_empirical_data)
show(evolved_models_empirical_data)
summary(evolved_models_empirical_data)

data <- data.frame(y = evolved_models_empirical_data@varImp, x= c("cc", "dc", "cd", "dd"))
p <- ggplot(data, aes(x = x, y=y)) + geom_bar(stat="identity") + coord_flip() +
        ylab("Relative Importance") +
        xlab("Variables")
p

plot(evolved_models_empirical_data@GA,
     cex.points = 1.2, cex.lab = 1.1, cex.axis = 1.1,
     col = c("green3", "dodgerblue3", adjustcolor("green3", alpha.f = 0.1)),
    pch = c(16, 1), lty = c(1,2), grid = graphics:::grid)
}
}

